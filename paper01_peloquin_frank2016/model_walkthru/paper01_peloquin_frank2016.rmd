---
title: "paper01 model walkthru"
subtitle: "Peloquin & Frank (2016), 'Determining the alternatives for scalar implicature'"
author: "timothy leffel"
date: "oct20/2017"
---


### Gameplan

- recap of paper 
- what the model is (broad strokes)
- what the model does 
- ...

### Recap of Paper

### Model 


```{r}
lefftpack::lazy_setup()
# devtools::install_github("benpeloquin7/rrrsa")
library("rrrsa")

### CONTENTS -------

# SIX DATASETS

# THREE HELPER FUNCTIONS

# SIX ANALYSIS FUNCTIONS

### DATASETS ------------------------------------------------------------------

# note: on any dataset `df`, start by calling `?df` to see info 

# example docs for `rrrsa::peloquinFrank_2Alts`
# 
#   This data set contains empirical literal listener semantics and pragmatic
#   judgments for entailment items (two alternatives) from Peloquin & Frank 2016
# 
#   1) quantityVarName :: "stars"
#   2) semanticsVarName :: "speaker.p"
#   3) itemVarName :: "words"
#   4) groupVarName :: "scale"
#   other) experiment number :: "exp"
#   other) Pragmatic judgments study 1 (e6), study 2 (e11)
# 
#   see also: https://github.com/langcog/scalar_implicature

# 136x16 df, data from frank et al. (under review)
rrrsa::d_pragmods

# 50x7 df, data from pel+frk16, 
rrrsa::peloquinFrank_2Alts

# 75x7 df
rrrsa::peloquinFrank_3Alts

# 100x7 df
rrrsa::peloquinFrank_4Alts

# 125x7 df 
rrrsa::peloquinFrank_5Alts




### HELPER FUNCTIONS ----------------------------------------------------------

# converts vec2 to whatever type vec1 is
rrrsa::rsa.convertVecType(vec1, vec2)

# this is just `function(x) x/sum(x)` for positive `x`
rrrsa::rsa.normVec(v)

# just changes desired column names 
rrrsa::rsa.renameCol(df, currNames, replacements)




### ANALYSIS FUNCTIONS --------------------------------------------------------

### `rrrsa::rsa.informativity(m_u, alpha, cost)` -------
# ifelse(m_u == 0, 0, exp(-alpha * (-log(m_u) - cost)))
rrrsa::rsa.informativity(m_u, alpha, cost)


### `rrrsa::rsa.utility(items, costs, alpha)` ------
# rsa.normVec(mapply(rsa.informativity, items, costs, alpha = alpha))
rrrsa::rsa.utility(items, costs, alpha)


### `rrrsa::rsa.reason(m, costs, priors, depth, alpha)` ----
rrrsa::rsa.reason(m, costs, priors, depth, alpha, usePriorEveryRecurse)


### `rrrsa::rsa.runDf()` ----------------
rrrsa::rsa.runDf(data, quantityVarName, semanticsVarName, 
                 itemVarName, costsVarName, priorsVarName, depth, alpha,
                 usePriorEveryRecurse)


### `rrrsa::rsa.tuneDepthAlpha()` --------
rrrsa::rsa.tuneDepthAlpha()


### rrrsa::rsa.fullRecursion(m, costs, priors, alpha) ------
# `m` a matrix
# `costs` a vector of costs, w length == ncol(m) (defaults to zeros)
# `priors` vector of priors, w length == nrow(m) (defaults to ones)
# `alpha` scalar noise param, defaults to 1 
# returns a posterior distribution 
rrrsa::rsa.fullRecursion(m, costs, priors, alpha)

# pdist=runif; nvals=100; ncols=4; params=c(0,1)
fullrec <- function(pdist, nvals, ncols, params){
  set.seed(3369)
  m <- matrix(pdist(nvals, params[1], params[2]), ncol=ncols)
  if (min(m) < 0) message("converting negative vals to positive")
  m <- abs(m); m <- m/sum(m)
  m_post <- rrrsa::rsa.fullRecursion(m=m)
  par(mfrow=c(1,3)); print(hist(m)); print(hist(m_post)); print(plot(m, m_post))
  title(paste0("with nvals=",nvals," ncols=",ncols, 
               "\nparams=",paste(params, collapse=",")))
}
lapply(c(2,4,5,10,100), function(ncols){
  fullrec(pdist=runif, nvals=1e3, ncols=ncols, params=c(0,1))
})
lapply(c(2,4,5,10,100), function(ncols){
  fullrec(pdist=rnorm, nvals=1e3, ncols=ncols, params=c(0,1))
})

```

